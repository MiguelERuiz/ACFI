\documentclass{beamer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definicion de paquetes
\usepackage{minted}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{xargs}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{pgfpages}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definición de comandos
\setlength{\marginparwidth}{2cm}
% \unsure{I'm not sure}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
% \change{This must be changed}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
% \info{Just information}
\newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
% \improvement{THIS must be improved}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=orange,backgroundcolor=orange!25,bordercolor=orange,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beamer
\usetheme{Madrid}
\AtBeginEnvironment{minted}{\fontsize{12}{12}\selectfont}
\setbeameroption{show notes on second screen=right}
% \setbeameroption{show only notes}
\setbeameroption{show notes}
% \setbeamertemplate{note page}[default]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Título
\title[ACFI]{Property-based Testing con PropEr}
\author{Miguel Emilio Ruiz Nieto}
\date{\today} % TODO poner la fecha del 3/11/2021
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Empieza el documento
\begin{document}
  \begin{frame}
    \titlepage
  \end{frame}

  \begin{frame}{Contenidos}
    \tableofcontents[hideallsubsections]
  \end{frame}

  \section{Motivación}
    \begin{frame}[fragile]{Motivación}
      \begin{minted}[fontsize=\small]{erlang}
        -module(sort_lib).

        -export([sort/1]).
        % Implementation of quicksort algorithm
        -spec sort(list(integer())) -> list(integer()).
        sort([]) -> [];
        sort([P|Xs]) ->
          sort([X || X <- Xs, X < P]) ++
              [P] ++ sort([X || X <- Xs, P =< X]).
      \end{minted}
    \end{frame}
    \begin{frame}[fragile]{Motivación. Test unitarios}
      \begin{minted}[fontsize=\small]{erlang}
        -module(sort_lib_eunit).

        -include_lib("eunit/include/eunit.hrl").

        sort_test_() ->
          [test_zero(), test_two(), test_four()].
        test_zero() ->
            ?_assertEqual([], sort_lib:sort([])).
        test_two() ->
            [?_assertEqual([17,42],
                    sort_lib:sort([X,Y]))
                      || {X,Y} <- [{17,42}, {42,17}]
            ].
        test_four() ->
            ?_assertEqual([1,1,3,4],
                    sort_lib:sort([3,1,4,1])).
      \end{minted}
    \end{frame}
    \begin{frame}{Motivación}
      \begin{block}{Preguntas}
        \begin{itemize}
          \item ¿Son buenos estos tests?
          \item ¿Harían falta más?
          \item En caso de que sí, ¿cuántos más?
        \end{itemize}
      \end{block}
    \end{frame}

    \begin{frame}{Motivación}
      Las metodologías de testing tradicionales son útiles ya que:
      \begin{itemize}
        \item Obliga a los desarrolladores a escribir casos de prueba\\
        del software desarrollado
        \item Para cada input se debe generar un cierto output con el fin\\
        de comprobar el correcto funcionamiento del sistema
      \end{itemize}
    \end{frame}

    \begin{frame}{Motivación}
      Pero tienen sus inconvenientes:
      \begin{itemize}
        \item Consumen tiempo (€€€)
        \item No se garantiza que la batería de tests cubra todos los casos
      \end{itemize}
    \end{frame}

    \begin{frame}{Motivación}
      \begin{exampleblock}{La solución}
        \textbf{Property-based testing}
      \end{exampleblock}
    \end{frame}
  \section{Definiciones}
    \begin{frame}{Property-based Testing. Definición}
      \begin{itemize}
        \item Es una técnica para hacer pruebas sobre las propiedades\\
        de nuestro sistema
        \item Los tests no son sobre casos de uso, sino sobre el\\
        comportamiento del propio sistema
        \item Muy común en lenguajes de programación funcional (i.e Quickcheck)
      \end{itemize}
    \end{frame}
    \begin{frame}{Propiedades}
      \begin{itemize}
        \item Son reglas generales que describen el comportamiento de una\\
        función o un programa
        \item Han de ser aplicables a cualquier tipo de entrada y salida del\\
        propio programa
        \item La salida debe verificar ciertas características deseadas
      \end{itemize}
    \end{frame}
    \begin{frame}{Propiedades}
      Al principio puede resultar no tan trivial como los tests unitarios ya que:
      \begin{itemize}
        \item El desarrollador ha de tener una visión más nítida de los\\
        casos de uso y del comportamiento del sistema
      \end{itemize}
      No obstante:
      \begin{itemize}
        \item Asegura encontrar un mayor número de ``casos esquina'' y bugs\\
        dentro del código
      \end{itemize}
    \end{frame}
  \section{Erlang}
    \subsection{Historia}
    \begin{frame}{Erlang}
      \begin{itemize}
        \item Lenguaje de programación desarrollado en Ericsson
        \item Orientado a sistemas distribuidos:
        \begin{itemize}
          \item Modelo de actores
          \item Paso de mensajes
          \item Tolerancia a fallos
          \item Alta disponibilidad
          \item Filosofía "Let it crash"
        \end{itemize}
      \end{itemize}
    \end{frame}
    \subsection{Sintaxis}
    \begin{frame}[fragile]{Sintaxis. Módulos y funciones}
      \begin{minted}{erlang}
        -module(sucessions).
        -export([fib/1]).

        fib(0) -> 0;
        fib(1) -> 1;
        fib(N) -> fib(N-1) + fib(N-2).
      \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Sintaxis. Listas}
      \begin{minted}{erlang}
        1> [First | TheRest] = [1,2,3,4,5].
        2> First.
        1
        3> TheRest.
        [2,3,4,5]
      \end{minted}
    \end{frame}
      %%% Tuplas
    \begin{frame}[fragile]{Sintaxis. Tuplas}
      \begin{minted}{erlang}
        4> X = 10, Y = 4.
        4
        5> Point = {X,Y}.
        {10,4}
        6> PreciseTemperature = {celsius, 23.213}.
      \end{minted}
    \end{frame}
    %%% Pattern Matching??
    \begin{frame}[fragile]{Sintaxis. Funciones de Orden Superior}
      \begin{minted}{erlang}
        7> Add_3 = fun(X) -> X + 3 end.
        #Fun<erl_eval.7.126501267>
        8> lists:map(Add_3, [1,2,3]).
        [4,5,6]
      \end{minted}
    \end{frame}
    %%% Paso de mensajes??
  \section{PropEr}
    \begin{frame}{PropEr}
      \begin{itemize}
        \item Herramienta para realizar property-based testing en Erlang
        \item Inspirada en Quickcheck
        \item Completamente integrada con los tipos de Erlang
      \end{itemize}
    \end{frame}

    \begin{frame}{PropEr}
      Nos centraremos en los siguientes aspectos:
      \begin{itemize}
        \item Generadores
        \item Estructura de las propiedades
        \item Propiedades sin estado
        \item Propiedades con estado
        \item Reducción de casos con \mintinline{erlang}{?SHRINK}
      \end{itemize}
    \end{frame}


    \subsection{Generadores}
      \begin{frame}{PropEr. Generadores}
        \begin{itemize}
          \item Funciones que \textit{generan} entradas de una manera ``aleatoria''
          \item Proporcionan datos en base al tipo del generador y a los filtros dados
          \item Pueden ser:
          \begin{itemize}
            \item En base a los tipos de Erlang
            \item Customizados por el desarrollador
          \end{itemize}
        \end{itemize}
      \end{frame}

      \begin{frame}{PropEr. Generadores. Ejemplos}
        Basados en los tipos de Erlang
        \begin{block}{~\vspace{0.7cm}}
          \begin{center}
          \vspace{-0.8cm}
          \begin{tabular}{p{0.45\textwidth}|p{0.45\textwidth}}
            \textcolor{white}{\bf Generador} & \textcolor{white}{\bf Muestra} \\
              \mint{erlang}{integer()} & \mint{erlang}{89234} \\ \hline
              \mint{erlang}{boolean()} & \mint{erlang}{true, false} \\ \hline
              \mint{erlang}{list(Type)} & \mint{erlang}{[true, true, false]} \\ \hline
              \mint{erlang}{tuple()} & \mint{erlang}{{true, 13.321123, -67}} \\
          \end{tabular}
          \end{center}
        \end{block}
      \end{frame}
    \subsection{Estructura de las propiedades}
    \subsection{Generadores}
    \subsection{Invariantes}
    \subsection{Propiedades sin estado}
    \subsection{Propiedades con estado}
    \subsection{?SHRINK}
  \section{Un caso real}
    \begin{frame}{Un caso real}

    \end{frame}
  \section{Bibliografía}
    \begin{frame}{Bibliografía}
      \begin{itemize}
        \item Getting Started with Erlang \url{https://www.erlang.org/doc/getting_started/intro.html}
        \item PropEr Guide \url{https://proper-testing.github.io}
        \item Property-Based Testing with PropEr, Erlang and Elixir \url{https://www.propertesting.com/}
        \item Baleen repo \url{https://github.com/coowry/baleen}
      \end{itemize}
    \end{frame}
\end{document}