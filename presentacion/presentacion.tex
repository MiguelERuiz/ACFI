\documentclass{beamer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definicion de paquetes
\usepackage{minted}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definición de comandos
\setlength{\marginparwidth}{2cm}
\newcommand{\unsure}[2]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommand{\change}[2]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommand{\info}[2]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommand{\improvement}[2]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommand{\thiswillnotshow}[2]{\todo[disable,#1]{#2}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beamer
\usetheme{Madrid}
\AtBeginEnvironment{minted}{\fontsize{12}{12}\selectfont}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Título
\title[ACFI]{Property-based Testing con PropEr}
\author{Miguel Emilio Ruiz Nieto}
\date{\today} % TODO poner la fecha del 3/11/2021
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Empieza el documento
\begin{document}
  \begin{frame}
    \titlepage
  \end{frame}

  \begin{frame}{Contenidos}
    \tableofcontents[hideallsubsections]
  \end{frame}

  \section{Motivación}
    \begin{frame}[fragile]{Motivación}
      \begin{minted}[fontsize=\small]{erlang}
        -module(sort_lib).

        -export([sort/1]).
        % Implementation of quicksort algorithm
        -spec sort(list(integer())) -> list(integer()).
        sort([]) -> [];
        sort([P|Xs]) ->
          sort([X || X <- Xs, X < P]) ++
              [P] ++ sort([X || X <- Xs, P =< X]).
      \end{minted}
    \end{frame}
    \begin{frame}[fragile]{Motivación. Test unitarios}
      \begin{minted}[fontsize=\small]{erlang}
        -module(sort_lib_eunit).

        -include_lib("eunit/include/eunit.hrl").

        sort_test_() ->
          [test_zero(), test_two(), test_four()].
        test_zero() ->
            ?_assertEqual([], sort_lib:sort([])).
        test_two() ->
            [?_assertEqual([17,42],
                    sort_lib:sort([X,Y]))
                      || {X,Y} <- [{17,42}, {42,17}]
            ].
        test_four() ->
            ?_assertEqual([1,1,3,4],
                    sort_lib:sort([3,1,4,1])).
      \end{minted}
    \end{frame}
    \begin{frame}{Motivación}
      \begin{block}{Preguntas}
        \begin{itemize}
          \item ¿Son buenos estos tests?
          \item ¿Harían falta más?
          \item En caso de que sí, ¿cuántos más?
        \end{itemize}
      \end{block}
    \end{frame}

    \begin{frame}{Motivación}
      Las metodologías de testing tradicionales son útiles ya que:
      \begin{itemize}
        \item Obliga a los desarrolladores a escribir casos de prueba\\
        del software desarrollado
        \item Para cada input se debe generar un cierto output con el fin\\
        de comprobar el correcto funcionamiento del sistema
      \end{itemize}
    \end{frame}

    \begin{frame}{Motivación}
      Pero tienen sus inconvenientes:
      \begin{itemize}
        \item Consumen tiempo (€€€)
        \item No se garantiza que la batería de tests cubra todos los casos
      \end{itemize}
    \end{frame}

    \begin{frame}{Motivación}
      \begin{exampleblock}{La solución}
        \textbf{Property-based testing}
      \end{exampleblock}
    \end{frame}
  \section{Definiciones}
    \begin{frame}{Property-based Testing. Definición}
      \begin{itemize}
        \item Es una técnica para hacer pruebas sobre las propiedades\\
        de nuestro sistema
        \item Los tests no son sobre casos de uso, sino sobre el\\
        comportamiento del propio sistema
        \item Muy común en lenguajes de programación funcional (i.e Quickcheck)
      \end{itemize}
    \end{frame}
    \begin{frame}{Propiedades}
      \begin{itemize}
        \item Son reglas generales que describen el comportamiento de una\\
        función o un programa
        \item Han de ser aplicables a cualquier tipo de entrada y salida del\\
        propio programa
        \item La salida debe verificar ciertas características deseadas
      \end{itemize}
    \end{frame}
    \begin{frame}{Propiedades}
      Al principio puede resultar no tan trivial como los tests unitarios ya que:
      \begin{itemize}
        \item El desarrollador ha de tener una visión más nítida de los\\
        casos de uso y del comportamiento del sistema
      \end{itemize}
      No obstante:
      \begin{itemize}
        \item Garantiza encontrar mayor número de ``casos esquina'' y bugs\\
        dentro del código
      \end{itemize}
    \end{frame}
  \section{Erlang}
    \subsection{Historia}
    \begin{frame}{Erlang}
      \begin{itemize}
        \item Lenguaje de programación desarrollado en Ericsson
        \item Orientado a sistemas distribuidos:
        \begin{itemize}
          \item Modelo de actores
          \item Paso de mensajes
          \item Tolerancia a fallos
          \item Alta disponibilidad
          \item Filosofía "Let it crash"
        \end{itemize}
      \end{itemize}
    \end{frame}
    \subsection{Sintaxis}
    \begin{frame}[fragile]{Sintaxis. Módulos y funciones}
      \begin{minted}{erlang}
        -module(sucessions).
        -export([fib/1]).

        fib(0) -> 0;
        fib(1) -> 1;
        fib(N) -> fib(N-1) + fib(N-2).
      \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Sintaxis. Listas}
      \begin{minted}{erlang}
        1> [First | TheRest] = [1,2,3,4,5].
        2> First.
        1
        3> TheRest.
        [2,3,4,5]
      \end{minted}
    \end{frame}
      %%% Tuplas
    \begin{frame}[fragile]{Sintaxis. Tuplas}
      \begin{minted}{erlang}
        4> X = 10, Y = 4.
        4
        5> Point = {X,Y}.
        {10,4}
        6> PreciseTemperature = {celsius, 23.213}.
      \end{minted}
    \end{frame}
    %%% Pattern Matching??
    \begin{frame}[fragile]{Sintaxis. Funciones de Orden Superior}
      \begin{minted}{erlang}
        7> Add_3 = fun(X) -> X + 3 end.
        #Fun<erl_eval.7.126501267>
        8> lists:map(Add_3, [1,2,3]).
        [4,5,6]
      \end{minted}
    \end{frame}
    %%% Paso de mensajes??
  \section{PropEr}
    \begin{frame}{PropEr}

    \end{frame}
    \subsection{Estructura de las propiedades}
    \subsection{Generadores}
    \subsection{Invariantes}
    \subsection{Propiedades sin estado}
    \subsection{Propiedades con estado}
    \subsection{?SHRINK}
  \section{Un caso real}
    \begin{frame}{Un caso real}

    \end{frame}
  \section{Bibliografía}
    \begin{frame}{Bibliografía}
      \begin{itemize}
        \item Getting Started with Erlang \url{https://www.erlang.org/doc/getting_started/intro.html}
        \item PropEr Guide \url{https://proper-testing.github.io}
        \item Property-Based Testing with PropEr, Erlang and Elixir \url{https://www.propertesting.com/}
        \item Baleen repo \url{https://github.com/coowry/baleen}
      \end{itemize}
    \end{frame}
\end{document}